\NeedsTeXFormat{LaTeX2e}
\documentclass[a4paper,12pt,
headsepline,           % Linie zw. Kopfzeile und Text
oneside,               % einseitig
pointlessnumbers,      % keine Punkte nach den letzten Ziffern in Überschriften
bibtotoc,              % LV im IV
%DIV=15,               % Satzspiegel auf 15er Raster, schmalere Ränder   
%BCOR15mm               % Bindekorrektur
%,draft
]{scrartcl}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage[utf8]{inputenc} % this is needed for umlauts
\usepackage[ngerman]{babel} % this is needed for umlauts
\usepackage[T1]{fontenc} 
\usepackage{commath}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{float}
\usepackage{tikz-timing}
\usepackage{tikz}
\usepackage{multirow}
\usepackage[final]{pdfpages}
\usepackage{blindtext}
\usepackage[scaled]{helvet}
\usepackage{hyperref}
\usepackage{comment}
\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

\usetikzlibrary{calc,shapes.multipart,chains,arrows}

\KOMAoptions{DIV=last} % Neuberechnung Satzspiegel nach Laden von Paket helvet

\usepackage{scrpage2}
\pagestyle{useheadings}

\renewcommand{\familydefault}{\sfdefault} 

\setlength{\parindent}{0pt}   % kein linker Einzug der ersten Absatzzeile
\setlength{\parskip}{1.4ex plus 0.35ex minus 0.3ex} % Absatzabstand, leicht variabel

\newcommand{\fullname}{Gruppe 10}
\newcommand{\titel}{Softwaregrundprojekt Meilenstein 1}
\newcommand{\jahr}{2018}
\newcommand{\dozent}{Florian Ege}
\newcommand{\betreuer}{Stefanos Mytilineos}
\newcommand{\fakultaet}{Ingenieurwissenschaften, Informatik und\\Psychologie}
\newcommand{\institut}{Institut für Softwaretechnik und Programmiersprachen}

\pdfinfo{
    /Author (\fullname)
    /Title (\titel)
    /Producer     (pdfeTex 3.14159-1.30.6-2.2)
    /Keywords ()
}

\hypersetup{
    pdftitle=\titel,
    pdfauthor=\fullname,
    pdfsubject={Softwaregrundprojekt-Abgabe},
    pdfproducer={pdfeTex 3.14159-1.30.6-2.2},
    colorlinks=false,
    pdfborder=0 0 0	% keine Box um die Links!
}

% Trennungsregeln
\hyphenation{Sil-ben-trenn-ung}


\newcommand{\begriff}[7] {
	\begin{table}[H]
		\centering
		\begin{tabular}{|p{2,5cm}|p{12cm}|}
			%\hline
			%\toprule \\
			\hline
			\textbf{Begriff} & \textbf{#1} \\ \hline
			%\midrule \\
			\textbf{Beschreibung} & #2 \\ \hline
			%\midrule
			\textbf{Ist-ein} & #3 \\ \hline
			%\midrule
			\textbf{Kann-sein} & #4 \\ \hline
			%\midrule
			\textbf{Aspekt} & #5 \\ \hline
			%\midrule
			\textbf{Bemerkung} & #6 \\ \hline
			%\midrule
			\textbf{Beispiel} & #7 \\ %\hline
			%\bottomrule
			\hline
		\end{tabular}
	\end{table}
}

%\title{Softwaregrundprojekt}
%\author{Gruppe 10}

\newcommand{\anf}[7] {
    \begin{table}[H]
        \centering
        \begin{tabular}{|p{3.2cm}|p{11.3cm}|}
        	\hline
            \textbf{ID:} & \textbf{#1} \\ \hline
            \textbf{Titel:} & #2 \\ \hline
            \textbf{Beschreibung:} & #3 \\ \hline
            \textbf{Begründung:} & #4 \\ \hline
            \textbf{Abhängigkeiten:} & #5 \\ \hline
            \textbf{Priorität:} & #6 \\ \hline
            \textbf{Akteure:} & #7 \\ \hline
        \end{tabular}
    \end{table}
}

\newcounter{fanfCount}
\newcommand{\fanf}[6] {
    \stepcounter{fanfCount}
    \anf{FA\thefanfCount}{#1}{#2}{#3}{#4}{#5}{#6}
}
\newcounter{qanfCount}
\newcommand{\qanf}[6] {
    \stepcounter{qanfCount}
    \anf{QA\theqanfCount}{#1}{#2}{#3}{#4}{#5}{#6}
}

\newcommand{\akt}[4] {
    \begin{table}[H]
        \centering
        \begin{tabular}{|p{3cm}|p{11.5cm}|}
        	\hline
            \textbf{ID:} & \textbf{#1} \\ \hline
            \textbf{Titel:} & #2 \\ \hline
            \textbf{Beschreibung:} & #3 \\ \hline
            \textbf{Rolle:} & #4 \\ \hline
        \end{tabular}
    \end{table}
}

\newcounter{faktCount}
\newcommand{\fakt}[3] {
    \stepcounter{faktCount}
    \akt{AKT\thefaktCount}{#1}{#2}{#3}
}

\begin{document}
    \thispagestyle{empty}
    \begin{addmargin*}[4mm]{-10mm}

        \includegraphics[height=1.8cm]{images/unilogo_bild}
        \hfill
        \includegraphics[height=1.8cm]{images/unilogo_wort}\\[1em]

        {\footnotesize
        %{\bfseries Universität Ulm} \textbar ~89069 Ulm \textbar ~Germany
        \hspace*{115mm}\parbox[t]{35mm}{\bfseries Fakultät für\\
        \fakultaet\\
        \mdseries \institut}\\[2cm]

        \parbox{140mm}{\bfseries \LARGE \titel}\\[2.5em]
        {\footnotesize Softwaregrundprojekt an der Universität Ulm}\\[3em]

        {\footnotesize \bfseries Vorgelegt von:}\\
        {\footnotesize \fullname\\}\\ [1em]
        {\footnotesize \bfseries Dozent:}\\
        {\footnotesize \dozent\\}\\[1em]
        {\footnotesize \bfseries Betreuer:}\\
        {\footnotesize \betreuer}\\ [1em]
        {\footnotesize \jahr}
        }
    \end{addmargin*}
    \pagebreak
    \tableofcontents
    \pagebreak

    \section{Kontextanalyse}
    \input{kontextanalyse.tex}
    \section{Fachwissen}
    \input{Aufgabe_2_Fachwissen.tex}
    \includepdf[scale = 0.8, pagecommand={\section{Domänenmodell}}]{domaenenmodell.pdf}
    \section{Anforderungsdefinition}
    
	\textbf{Bemerkungen zu den Abhängigkeiten der Anforderungen:} \\
	Abhängigkeiten werden aus Gründen der Übersichtlichkeit vererbt. Beispielsweise besitzt die Mittelzelle implizit alle Abhängigkeiten des Mittelkreises.     
    
    \subsection{Akteure}
    
    \fakt	{Nutzer}
			{Menschlicher Nutzer, der eine Anwendungen bedient.}
			{Ein Mensch, der entweder als Spieler aktiv an einem Spiel teilnimmt, als Gast passiv einem Spiel zusieht oder den Quidditchteam-Editor benutzt.}
			
	\fakt	{Spieler}
			{Spiet das Spiel \glqq{}Fantastic Feasts\grqq{}.}
			{Nimmt aktiv Einfluss auf das Spielgeschehen. Ist entweder Nutzer oder KI.}
			
	\fakt	{Gast}
			{Nutzer, der mit der Client-Anwendung ein laufendes Spiel beobachtet.}
			{Beobachtet eine Partie als Außenstehender, hat jedoch keinen Einfluss auf das Spielgeschehen.}
		
	\fakt	{Systemadministrator}
			{Person, die die Möglichkeit hat, die Serveranwendung des Projektes zu verwalten.}
			{Der Systemadministrator ist dafür verantwortlich, eine Instanz der Serveranwendung zu starten und zu betreuen. Zudem hat er Zugriff auf die Partie-Konfiguration und kann diese bei Bedarf verändern.}
	
	\fakt	{Entwickler}
			{Person, die an der Entwicklung der Anwendung beteiligt ist.}
			{Der Entwickler implementiert die gesamte Anwendung.}	
	
	\fakt	{KI}
			{Vom Computer gesteuerter Spieler.}
			{Spieler, dessen Entscheidungen und Züge von einem Computerprogramm, dem KI-Client, getroffen werden. Es wird somit ein menschlichen Spieler.}
	
	\fakt	{Kunde}
			{Der Kunde gibt das Projekt in Auftrag.}
			{Stellt Anforderungen und Wünsche an das Entwicklerteam und nimmt das Projekt ab.}
	
	\fakt	{Client}
			{Programm, das einem Nutzer eine grafische Oberfläche, zum Spielen oder Beobachten des Spiels, zur Verfügung stellt.}
			{Der Client stellt eine Verbindung zum Server her, visualisiert die empfangenen Daten und sendet seinerseits die Eingaben des Nutzers.}
	
	\fakt	{KI-Client}
			{Simuliert einen menschlichen Gegner.}
			{Der KI-Client kommuniziert wie der normale Client mit dem Server. Allerdings werden die Entscheidungen von der KI getroffen und nicht von einem Nutzer. Er stellt keine grafische Oberfläche zur Verfügung.}
	
	\fakt	{Server}
			{Zentrale Komponente des Projekts, die alle anderen Komponenten vernetzt.}
			{Auf dem Server läuft die eigentliche Spiellogik. Er fungiert dabei als Bindeglied zwischen den am Spiel beteiligten Clients und stellt für diese alle benötigten Informationen, wie etwa die Spielfeldkonfiguration oder die Züge des Gegners, bereit.}
			
	\fakt	{Quidditchteam-Editor}
			{Computerprogramm, mit dem Team-Konfigurationen erstellt und bearbeitet werden können.}
			{Der Quidditchteam-Editor erstellt Teamkonfigurationsdateien, die später vom Client geladen werden, um ein Spiel zu starten.}
	
	\subsection{Allgemeine funktionale Anforderungen} 
	
	\fanf	{Quidditch-Spielfeld}
			{Das Quidditch-Spielfeld hat eine Ovale Form, die in ein Raster von 17x13 quadratischen Zellen eingepasst ist. Auf diesem Feld finden alle Spielhandlungen statt, die während dem Spiel getätigt werden können.}
			{Das Spielfeld ist die zentrale Komponente des Spiels, da sich hier während einer Partie sämtliche Abläufe abspielen.}
			{-}
			{++}
			{Spieler, KI, Gast, Client, KI-Client, Server}
	
	\fanf	{Mittelkreis}
			{Der Mittelkreis ist ein Bereich auf dem Quidditch-Spielfeld, der in der Mitte angeordnet ist und aus 3x3 quadratischen Zellen besteht. Zu Beginn dürfen sich hier keine Spielfiguren befinden.}
			{Der Mittelkreis markiert das Zentrum des Spielfeldes, in dem das Spiel gestartet wird.}
			{Spielfeld}
			{+}
			{Spieler, KI, Gast, Client, KI-Client, Server}
	
	\fanf	{Mittelzelle}
			{Die Mittelzelle stellt den mittleren Punkt des Mittelkreises dar, der sich im Zentrum des Quidditch-Spielfeldes befindet. Dort werden initial die Bälle des Spiels platziert.}
			{Die Mittelzelle ist der Startpunkt für die Bälle beim Spielstart.}
			{Mittelkreis}
			{+}
			{Spieler, KI, Gast, Client, KI-Client, Server}
	
	\fanf	{Hüterzonen}
			{Die Hüterzonen sind an den jeweils gegenüberliegenden Seiten des Quidditch-Spielfeldes platziert. Die Hüterzonen sind ovalförmig, bestehen aus 11x5 Kacheln und beinhalten jeweils 3 Torringe.}
			{In den Hüterzonen können die Teams Punkte erzielen.}
			{Spielfeld}
			{++}
			{Spieler, KI, Gast, Client, KI-Client, Server}
			
	\fanf	{Zelle}
			{Die Zelle ist die kleinste Einheit des Spielfeldes, auf ihr darf sich immer nur eine Spielfigur gleichzeitig befinden. Bälle können sich jedoch eine Zelle mit einem anderen Ball und / oder einer Spielfigur teilen.}
			{Das gesamte Spielfeld ist aus Zellen aufgebaut. Sie bestimmen, wie sich Spielobjekte bewegen können.}
			{Spielfeld}
			{++}
			{Spieler, KI, Gast, Client, KI-Client, Server}
	
	\fanf	{Torring}
			{Die Teams können Punkte erzielen, indem sie den Quaffel durch einen generischen Torring werfen.}
			{Die Torringe dienen den Teams als Hauptquelle von Punkten.}
			{Hüterzone}
			{++}
			{Spieler, KI, Gast, Client, KI-Client, Server}
			
	\fanf	{Schussvektorberechnung}
			{Ein Schussvektor zeigt vom Mittelpunkt der Startzelle auf die Zielzelle des Wurfs. Alle Zellen, die von diesem Vektor geschnitten werden, sind so genannte überstrichene Felder.}
			{Ein Schussvektor beschreibt, wie eine Spielfigur einen Ball über das Spielfeld bewegten kann.}
			{Zelle}
			{++}
			{Spieler, KI, Gast, Client, KI-Client, Server}
			
	\fanf	{Punkte erzielen}
			{Es gibt zwei Möglichkeiten, Punkte zu erzielen: Den Quaffel durch ein gegnerischen Torring werfen (entspricht 10 Punkten) oder den Goldenen Schnatz fangen (entspricht 30 Punkten).}
			{Die Punktezahl zeigt an, welcher Spieler sich im Moment besser schlägt und dient zur Bestimmung des Gewinners am Ende der Partie.}
			{Schnatz fangen, Quaffel werfen}
			{+}
			{Spieler, KI, Gast, Client, KI-Client, Server}
	
	\fanf	{Entfernungsberechnung}
			{Die Entfernung zwischen zwei Zellen ist die kleinstmögliche Anzahl an Zügen, die man braucht, um Zelle A zu Zelle B zu kommen. Dabei darf  man sich in alle Richtengen bewegen, also Vertikal, Horizontal und Diagonal.}
			{Die Entfernung ist maßgeblich für den Erfolg von verschiedenen Aktionen, wie z.B. dem Werfen des Quaffels.}
			{Zelle}
			{++}
			{Spieler, KI, Gast, Client, KI-Client, Server}
	
	\fanf	{Bälle}
			{Es gibt 3 verschiedene Arten von Bällen: Der Quaffel, der Klatscher und der Goldene Schnatz.}
			{Die Bälle sind zentraler Bestandteil des Spiels.}
			{-}
			{++}
			{Spieler, KI, Gast, Client, KI-Client, Server}
	
	\fanf	{Quaffel [Ball]}
			{Der Quaffel ist ein roter Lederball, mit dem die Team Punkte erzielen kann. Dazu muss der Quaffel durch einen gegnerischen Torring befördert werden.}
			{Der Quaffel ist die zentrale Punktequelle.}
			{Bälle}
			{++}
			{Spieler, KI, Gast, Client, KI-Client, Server}
	
	\fanf	{Klatscher [Ball]}
			{Der Klatscher ist ein kleiner schwarzer Ball, der sich von alleine auf Spieler zubewegt (eine Zelle pro Runde), die keine Treiber sind.}
			{Die Klatscher verleihen dem Spiel zusätzliche taktische Tiefe, da sie Spielfiguren für eine Runde ausschalten können.}
			{Bälle}
			{++}
			{Spieler, KI, Gast, Client, KI-Client, Server}
	
	\fanf	{Goldener Schnatz [Ball]}
			{Der Goldene Schnatz ist eine kleiner goldener Ball, sich von alleine von Suchern wegbewegt (eine Zelle pro Runde).}
			{Der Goldene Schnatz dient zum Punkteerzielen und führt, wenn er gefangen wird, zum Ende des Partie.}
			{Bälle}
			{++}
			{Spieler, KI, Gast, Client, KI-Client, Server}
	
	\fanf	{Besen}
			{Jede Spielfigur besitzt einen Besen, die einen der folgenden Typen haben: Zauberfauch, Sauberwisch 11, Komet 2-60, Nimbus 2001 und Feuerblitz. Der Typ des Besens bestimmt die Wahrscheinlichkeit, mit der eine Spielfigur nach einer Bewegung um ein Feld eine weitere Bewegung ausführen darf. Diese Wahrscheinlichkeit wird in der Partiekonfiguration festgelegt, wobei die Besen in der genannten Reihenfolge aufsteigende Wahrscheinlichkeiten besitzen.}
			{Die Besen geben den Spielfiguren eine unterschiedliche Qualität.}
			{-}
			{0}
			{Spieler, KI, Gast, Client, KI-Client, Server}
			
	\fanf	{Teams}
			{Ein Team besteht aus sieben Spielfiguren und sieben Fans. Außerdem hat jedes Team einen Namen, ein Motto, eine Hauptteamfarbe und eine Ersatzteamfarbe. Die sieben Spielfiguren Teilen sich wie folgt auf:  ein Hüter, zwei Treiber, drei Jäger und ein Sucher. Bei den Spielfiguren darf jedes Geschlecht bis zu vier mal vertreten sein. Zudem muss jeder Besentyp einmal vertreten sein. Bei den sieben Fans muss jeder Fantyp mindestens einmal vertreten sein.}
			{Quidditch ist ein Teamspiel, weshalb Teams benötigt werden.}
			{Spielfigur, Fans, Besen}
			{+}
			{Spieler}
	
	\fanf	{Spielfiguren}
			{Es gibt 4 Arten von Spielfiguren: Jäger, Sucher, Hüter und Treiber. Jede Spielfigur hat dabei einen Namen und ein Geschlecht.}
			{Die unterschiedlichen Typen der Spielfiguren geben dem Spiel taktische Tiefe.}
			{-}
			{++}
			{Spieler, KI, Gast, Client, KI-Client, Server}
	
	\fanf	{Jäger [Spielfigur]}
			{Jäger können den Quaffel aufnehmen und werfen und damit Punkte für ihr Team erzielen.}
			{Jäger können Punkte für ihr Team erzielen.}
			{Spielfigur}
			{++}
			{Spieler, KI, Gast, Client, KI-Client, Server}
	
	\fanf	{Treiber [Spielfigur]}
			{Treiber können den Klatscher schlagen und somit zum Gegner hin und / oder von Teammitgliedern weg befördern.}
			{Treiber dienen zum Schutz des eigenen Teams vor den Klatschern. Gleichzeitig können sie den Gegner aktiv sabotieren, in dem sie ihm den Klatscher zuspielen..}
			{Spielfigur}
			{++}
			{Spieler, KI, Gast, Client, KI-Client, Server}
	
	\fanf	{Hüter [Spielfigur]}
			{Hüter können den Quaffel aufnehmen und versuchen, den Gegner daran zu hindern, ein Tor zu erzielen. Landet der Quaffel auf einem Torring so geht der Quaffel am ende der Rudenphase in den Besitz des Hüters über, wenn er sich selbst in der Hüterzone befindet. Ein Hüter kann selbst keine Tore erzielen.}
			{Hüter stellen die Verteidigung seines Teams dar.}
			{Spielfigur, Hüterzone}
			{++}
			{Spieler, KI, Gast, Client, KI-Client, Server}
	
	\fanf	{Sucher [Spielfigur]}
			{Sucher versuchen den Goldenen Schnatz zu finden, um Punkte zu erzielen und das Spiel zu beenden.}
			{Der Sucher beendet das Spiel.}
			{Spielfigur, Goldener Schnatz}
			{++}
			{Spieler, KI, Gast, Client, KI-Client, Server}
			
	\fanf	{Quaffel-Werfen}
			{Hüter und Jäger können den Quaffel werfen. Der Wurf wird über ein Schussvektor angegeben. Jede gegnerische Spielfigur, die sich auf einer überstrichenen Zelle des Schussvektors befindet, kann den Quaffel abfangen. Wird der Ball von keiner Spielfigur abgefangen, so ist der Wurf mit der Wahrscheinlichkeit $P^d$ erfolgreich, wobei $P$ eine elementare Wurfwahrscheinlichkeit und $d$ die Entfernung zur Zielzelle ist. Ist der Wurf erfolgreich, so landet der Quaffel auf der Zielzelle. Wenn nicht wir der Quaffel auf einem zufälligen freien Zelle in einem $n\times n$ Quadrat um die Zielzelle platziert, wobei $n=\ceil{ \frac{d}{7}}$ ist.}			
			{Das Werfen des Quaffels ermöglicht Passspiel und das erzielen von Punkten.}
			{Schussvektorberechnung, Entfernungsberechnung, Spielfigur, Quaffel}
			{++}
			{Spieler, KI, Gast, Client, KI-Client, Server}
			
	\fanf	{Quaffel Abfangen}
			{Jede gegnerische Spielfigur auf einer überstrichenen Zelle des Schussvektors eines Wurfes hat eine gewisse Wahrscheinlichkeit, den Quaffel abzufangen. Diese Wahrscheinlichkeit ist in der Partiekonfiguration vermerkt. Gelingt das Abfangen, so landet der Quaffel auf der Zelle der Abfangenden Spielfigur.}
			{Das Abfangen bietet die Möglichkeit, Würfe des Gegners zu unterbinden.}
			{Quaffel-Werfen}
			{++}
			{Spieler, KI, Gast, Client, KI-Client, Server}
			
	\fanf	{Quaffel Verlieren}
			{Ein Jäger kann den Quaffel verlieren, dass bedeutet, das der Quaffel auf ein freie Nachbarzelle zufällig bewegt wird.}
			{Durch das Verlieren des Quaffels werden Tore im Alleingang erschwert.}
			{Spielfigur, Quaffel, Fouls, Klatscher}
			{+}
			{Spieler, KI, Gast, Client, KI-Client, Server}
		
	\fanf	{Quaffel Entreißen}
			{Ein Jäger darf einem anderen Jäger den Quaffel entreißen, sofern dieser auf einem seiner Nachbarfelder ist. Dies gelingt allerdings nur mit einer bestimmten Wahrscheinlichkeit. Jäger dürfen auch dem gegnerischen Hüter den Quaffel entreißen, jedoch dies geht nur, wenn sich der Hüter nicht in seiner eigenen Hüterzone befindet.}
			{Bietet zusätzliche Möglichkeiten, den Ball zu erobern.}
			{Spielfigur, Quaffel}
			{+}
			{Spieler, KI, Gast, Client, KI-Client, Server}
	
	\fanf	{Tor Erzielen}
			{Ein Jäger kann ein Tor erzielen, indem er den Quaffel erfolgreich auf eine Torringzelle wirft. Dabei muss der Schussvektor des Wurfes durch die linke oder rechte Seite der Torringzelle gehen.}
			{Stellt für einen Jäger die Möglichkeit dar, Punkte zu erzielen.}
			{Torring, Quaffel Werfen, Jäger}
			{+}
			{Spieler, KI, Gast, Client, KI-Client, Server}
			
	\fanf	{Klatscher Schlagen}
			{Ein Treiber kann einen Klatscher schlagen, wenn er sich auf derselben Zelle wie der Klatscher befindet. Der Treiber wählt, um den Klatscher zu schlagen, eine Zielzelle aus, die eine maximale Entfernung von drei zu ihm hat. Zusätzlich müssen auch alle überstrichenen Felder frei sein. Ist dies beides der Fall, so wird das Schlagen des Klatschen wie ein normaler Quaffel-Wurf behandelt, allerdings mit einer 100\% Wahrscheinlichkeit.}
			{Stellt für den Treiber die Möglichkeit dar, den Katscher zu bewegen.}
			{Spielfeld, Treiber, Klatscher}
			{+}
			{Spieler, KI, Gast, Client, KI-Client, Server}
			
	\fanf	{Spieler Betäuben}
			{Bewegt sich der Klatscher auf deine Zelle, auf der sich eine Spielfigur befindet, die kein Treiber ist, wird diese mit einer gewissen Wahrscheinlichkeit betäubt. Das hat zur Folge, dass diese Spielfigur gegebenenfalls den Quaffel verliert, keine Ball fangen und für eine Runde keine Aktion ausführen kann.}
			{Stellt ein zusätzliches taktisches Spielelement dar.}
			{Klatscher, Spielfigur}
			{+}
			{Spieler, KI, Gast, Client, KI-Client, Server}
			
	\fanf	{Schnatz Fangen}
			{Befindet sich ein Sucher und der Goldene Schnatz auf derselben Zelle, so fängt der Sucher den Goldenen Schnatz. Dadurch erhält sein Team 30 Punkte und das Spiel ist zu Ende.}
			{Das Schnatz Fange führ das Ende der Partie herbei.}
			{goldener Schnatz, Punkte}
			{++}
			{Spieler, KI, Gast, Client, KI-Client, Server}
			
	
	\fanf	{Fans}
			{Ein Fan kann durch Zaubersprüche das eigenen Team unterstützen oder das gegnerische Team schwächen. Diese Eingriffe in das Spielgeschehen werden  mit einer gewissen Wahrscheinlichkeit geahndet. Die Fans eines Teams werden jeweils vom Spieler des Teams gesteuert. Es gibt die folgenden Tyen von Fans: Elfen, Kobolde, Trolle und Niffler die alle unterschiedliche Fähigkeiten beherrschen.}
			{Erhöhen den Schwierigkeitsgrad, sorgen für Witz, und Überraschungen im Spiel.}
			{}
			{0}
			{Spieler, KI, Gast, Client, KI-Client, Server}
	
	\fanf	{Elfen [Fantyp]}
			{Elfen haben die Eigenschaft einen Spieler von der eigenen oder auch von der gegnerischen Mannschaft auf ein zufälliges freies Spielfeld zu Teleportieren.}
			{Siehe Fans}
			{Fans}
			{0}
			{Spieler, KI, Gast, Client, KI-Client, Server}
	
	\fanf	{Kobolde [Fantyp]}
			{Kobolde haben die Fähigkeit einen Schockzauber zu sprechen, welcher bewirkt, dass der Spieler den Quaffel fallen lässt, sofern er diesen hat und anschließend auf ein zufälliges freies Nachbarfeld gestoßen wird.}
			{Siehe Fans}
			{Fans}
			{0}
			{Spiel}
	
	\fanf	{Trolle [Fantyp]}
			{Durch lautes Brüllen sorgen Trolle dafür,dass der Spieler, welcher den Quaffel besitzt, diesen vor Schreck fallen lässt.}
			{Siehe Fans}
			{Fans}
			{0}
			{Spieler, KI, Gast, Client, KI-Client, Server}
	
	\fanf	{Niffler [Fantyp]}
			{Niffler lieben alles was glänzt, wodurch sie nach dem Goldenen Schnatz schnappen können, wodurch dieser eine Ausweichbewegung macht auf ein zufälliges freies Nachbarfeld von ihm.}
			{Siehe Fans}
			{Fans}
			{0}
			{Spieler, KI, Gast, Client, KI-Client, Server}
			
	\fanf	{Schiedsrichter}
			{Der Schiedsrichter ahndet mit einer gewissen Wahrscheinlichkeit Fouls von Spielern oder Fans. Ahndet der Schiedsrichter eine Aktion so wird die verursachende Spielfigur für eine Runde vom Spiel ausgeschlossen.}
			{Der Schiedsrichter ist die rechtschaffene Instanz und sorgt für Gerechtigkeit.}
			{Spielfigur, Fans}
			{+}
			{Spieler, KI, Gast, Client, KI-Client, Server}
	
	\fanf	{Foul}
			{Wie in jeder Sportart ist es in Quidditch möglich sich gegenseitig zu foulen. Es gibt dabei spezifische Fouls die nur von manchen bestimmten Spieler ausgeübt werden können und Fouls die von allen ausgeübt werden können. Nachdem eines der Fouls ausgeübt wurde, wird dieses Foul mit einer jeweils eigenen Wahrscheinlichkeit vom Schiedsrichter entdeckt, woraufhin der ausübende Spieler entsprechend bestraft wird.}
			{Diese Anforderung gehört zu einer Sportart einfach dazu, da Fouls bei jedem Sport vorkommen und das Spiel so spannender machen.}
			{Spiel}
			{+}
			{Spiel, Schiedsrichter}
	
	\fanf	{Flacken [Foul]}
			{Diese Aktion kann von jedem Spieler ausgeführt werden. Flacken bedeutet, dass ein Spieler sich direkt auf ein Torringfeld stellt, wodurch die Trefferwahrscheinlichkeit für den Schützen auf 0\% sinkt. Falls der Quaffel durch den Wurf auf das Torringfeld gekommen wäre, ohne vorher abgefangen zu werden, so springt der Quaffel auf ein zufälliges freies Nachbarfeld.}
			{Dieses Foul ermöglicht es dem Team Tore zu verhindern aber auf eine nicht regelkonforme Möglichkeit.}
			{Foul}
			{+}
			{Spiel, Schiedsrichter}
	
	\fanf	{Nachtarocken [Foul]}
			{Diese Aktion kann nur von Jägern ausgeübt werden. Führt ein Jäger diese Aktion aus, so erzielt er zu 100\% ein Tor, in dem er den Quaffel hält und damit auf ein Torringfeld fliegt, und diesen nicht, wie es die Regeln verlangen würden, von einem Feld außerhalb der Torringe wirft.}
			{Dieses Foul ermöglicht es dem Team Tore mit 100\% zu machen, aber man darf sich nicht erwischen lassen. Durch dieses Foul ist eventuell ein schnelleres Punkte holen ermöglicht und man kann eine Niederlage noch aufholen.}
			{Foul}
			{+}
			{Spiel, Schiedsrichter}
	
	\fanf	{Stutschen [Foul]}
			{Diese Aktion kann nur von Jägern ausgeübt werden. Bei diesem Foul fliegt ein zweiter Jäger in die gegnerische Hüterzone um seinem Team zu helfen Punkte zu machen, obwohl ein Team immer nur einen angreifenden Jäger in der gegnerischen Hüterzone haben darf.}
			{Dieses Foul hilft dem Team leichter einen Punkt zu machen, ist aber gegen die Regeln.}
			{Foul}
			{+}
			{Spiel, Schiedsrichter}
	
	\fanf	{Keilen [Foul]}
			{Dieses Foul können alle Spieler ausführen. Hierbei zieht ein Spieler auf das selbe Spielfeld wie ein gegnerischer Spieler, woraufhin dieser den Quaffel, sofern er diesen hat vertändelt und anschließend wird der gegnerische Spieler auf ein zufälliges freies Nachbarfeld verdrängt.}
			{Dieses Foul bietet die Möglichkeit den Ballbesitz wieder zu ändern, was aber auch nicht regelkonform ist eigentlich.}
			{Foul}
			{+}
			{Spiel, Schiedsrichter}
	
	\fanf	{Schnaltzeln [Foul]}
			{Dieses Foul können alle Spieler machen außer der Sucher. Dazu bewegt sich ein Spieler auf das Feld des Schnatzes, obwohl er kein Sucher ist, wodurch er verhindert, dass der Sucher den Schnatz fangen kann, da er das Feld blockiert und somit der Schnatz nicht gefangen werden kann.}
			{Diese Anforderung soll es dem Sucher schwerer machen den Schnatz zu fangen, da das gegnerische Team den Schnatz so blockieren kann.}
			{Foul}
			{+}
			{Spiel, Schiedsrichter}
			
	\fanf	{Setzen auf freies Nachbarfeld}
			{Soll ein Spieler oder Ball auf ein zufälliges freies Nachbarfeld von seiner Position gesetzt werden, aber es sind alle 8 umliegenden Felder bereits voll, oder können durch den Spielfeldrand nicht ausgewählt werden, so wird rekursiv von einem zufällig besetzten Nachbarfeld weiter gesucht, bis sich schließlich ein freies Feld findet. Dies bedeutet, dass der Spieler oder Ball nicht unbedingt auf einem Nachbarfeld seiner Position landet, sondern auch weiter entfernt gesetzt werden kann und so durch andere besetzte Felder sich hindurchtunnelt.}
			{Diese Anforderung ist notwendig, da man den Fall abdecken muss, falls kein freies Nachbarfeld mehr frei ist.}
			{Spielfeld}
			{++}
			{Spiel} 
			
	\fanf	{Partie-Konfiguration}
			{JSON Datei mit Informationen über eine Spiel. Zu den Informationen zählen die maximale Rundenzahl bevor die Überlängenbedingung eintritt, die Zeit, welche die Spieler haben um den nächsten gewünschten Zug zu übermitteln und welche Wahrscheinlichkeiten den einzelnen Ereignissen zugeordnet sind.}
			{Um das Spiel abwechslungsreicher zu gestalten ist es von Nöten, dass verschieden Abläufe in einer Partie angepasst werden können. Um Kompatibilität zwischen verschiedenen Komponenten zu gewährleisten ist es dabei zudem wichtig, dass diese Dateien einheitlich Formatiert sind.}
			{Spiellogik}
			{-+}
			{Server, Spiel, Systemadministrator}
	
	\fanf	{Quidditchteam-Konfiguration}
			{Lokal hinterlegte Datei im \textit{JSON} Format in der die Zusammensetzung des Teams eines Spielers hinterlegt ist.}
			{Die Konfiguration eines Teams muss zwischen dem Team-Editor und dem Client ausgetauscht werden können und muss daher in einer einheitlichen Datei lokal hinterlegt werden.}
			{Team, Spielfiguren}
			{+}
			{Nutzer, Client, KI-Client, Quidditchteam-Editor, Server}	
			
	\fanf	{Netzwerkschnittstelle}
			{Zwei Clients sollen über eine Netzwerkschnittstelle miteinander kommunizieren können.}
			{Bei \textit{Fantastic Feasts} handelt sich es um ein Online Multiplayer Spiel. Es ist also notwendig, dass einzelne Komponenten miteinander Kommunizieren können.}
			{-}
			{++}
			{Systemadministrator, Entwickler, Client, KI-Client, Server}
	
	\fanf	{Runde}
			{Das Spiel läuft in Runden ab. Jede Runde ist dabei in die drei Rundenphasen Ballphase, Spielerphase und Fanphase unterteilt.}
			{Bei \textit{Fantastic Feasts} handelt es sich laut den Spielregeln um ein Rundenbasiertes Spiel.}
			{Ballphase, Spielerphase, Fanphase}
			{+}
			{Spiel, Spieler, Team, Spielfigur}
	
	\fanf	{Ballphase}
			{In dieser Phase eine Spiels bewegen sich die Bälle über das Spielfeld. Dabei machen die beiden Klatscher ihre Bewegungen in zufälliger Reihenfolge.}
			{}
			{Runde}
			{+}
			{Spiel}
			
	\fanf	{Spielerphase}
			{<Beschreibung>}
			{Diese Anforderung geht aus den im Lastenheft zu Verfügung gestellten Spielregeln für das Spiel \textit{Fantastic Feasts} hervor.}
			{Runde}
			{+}
			{Spiel}
			
	\fanf	{Fanphase}
			{<Beschreibung>}
			{Diese Anforderung geht aus den im Lastenheft zu Verfügung gestellten Spielregeln für das Spiel \textit{Fantastic Feasts} hervor.}
			{Runde}
			{+}
			{Spiel}
			
	\fanf	{Spielende}
			{Die Partie ist vorüber und es gibt einen Gewinner. Dies ist der Fall wenn entweder ein Spieler Disqualifiziert wird oder ein Sucher in der Rundenphase den Goldenen Schnatz findet. Gewonnen hat dann das Team, das entweder nicht disqualifiziert wurde oder die meisten Punkte erzielt hat. Bei Punktegleichstand gewinnt das Team, welches den Goldenen Schnatz gefunden hat.}
			{Das Spielende muss erkannt und geprüft werden, damit ein Spieler der Partie zum Sieger gekrönt werden kann.}
			{Spiellogik, Runde, Goldener Schnatz, Sucher}
			{+}
			{Spiel, Spieler, Schiedsrichter}
			
	\fanf	{Überlängenbehandlung}
			{Reaktionen, welche getroffen werden, falls eine Partie zu lange läuft. Zieht sich ein Spiel über mehr Runden hin, als in der Partie-Konfiguration über einen Höchstwert fest,  ohne dass ein Sieger ermittelt werden kann, so wird das Verhalten des Goldenen Schnatz angepasst. Die Wahrscheinlichkeit, dass ein Sucher den Goldenen Schnatz findet wird auf 100\% gesetzt. Falls dann nach drei Runden das Spiel immer noch läuft bewegt sich der Goldenen Schnatz ohne Suchern auszuweichen in die Mitte des Spielfelds und verharrt dort. Wird der dort nach weiteren drei Runden immer noch nicht gewunden, so fliegt er in der nächsten Rundenphase dem nächsten Sucher ins Gesicht.}
			{Dadurch wird sichergestellt das ein Spiel spannend bleibt und die Spieler nicht die Lust verlieren, wenn eine Partie zu zäh läuft.}
			{Spielende, Spiellogik, Runde, Goldener Schnatz, Sucher}
			{-+}
			{Spiel, Spieler}
			
	\fanf	{Spiellogik}
			{Einheit, in der die Züge der Teams verarbeitet werden und auf Basis der Spielregeln im Lastenheft Entscheidungen getroffen werden. Zudem wird von der Spiellogik bestimmt welcher Spieler gerade am Zug ist.}
			{Ohne eine Spiellogik wären alle Anwendungen nutzlos.}
			{<Abhängigkeiten>}
			{++}
			{Server, Spiel}
	
	\fanf	{Log-Datei}
			{Datei zum Speichern bestimmter Ereignisse. Diese Datei wird lokal auf dem Endgerät hinterlegt.}
			{Um die während der Nutzung der Software aufgetretenen Aktionen im Nachhinein nachvollziehen zu können und daraus Informationen für Statistiken und Wartung ziehen zu können ist es wichtig das diese Aktionen lokal hinterlegt werden.}
			{Spiellogik}
			{-}
			{Client, KI-Client, Server}
			
	
	\subsection{Server spezifische funktionale Anforderungen}
	
	\fanf	{Spiellogik}
			{Einheit, in der die Züge der Teams verarbeitet werden und auf Basis der Spielregeln im Lastenheft Entscheidungen getroffen werden. Zudem wird von der Spiellogik bestimmt welcher Spieler gerade am Zug ist.}
			{Ohne eine Spiellogik wären alle Anwendungen nutzlos, da die Spiellogik die Einheit bildet, welche alles für das Spiel relevanten Informationen verarbeitet.}
			{Spiel, Benutzereingaben Validierung}
			{++}
			{Server, Spiel}
			
	\fanf	{Partie-Konfiguration}
			{JSON Datei mit Informationen über eine Spiel. Zu den Informationen zählen die maximale Rundenzahl bevor die Überlängenbedingung eintritt, die Zeit, welche die Spieler haben um den nächsten gewünschten Zug zu übermitteln und welche Wahrscheinlichkeiten den einzelnen Ereignissen zugeordnet sind.}
			{Um das Spiel abwechslungsreicher zu gestalten ist es von Nöten, dass verschieden Abläufe in einer Partie angepasst werden können. Um Kompatibilität zwischen verschiedenen Komponenten zu gewährleisten ist es dabei zudem wichtig, dass diese Dateien einheitlich Formatiert sind.}
			{Spiellogik}
			{-+}
			{Server, Spiel, Systemadministrator}
			
	\fanf	{Überlängenbehandlung}
			{Reaktionen, welche getroffen werden, falls eine Partie zu lange läuft. Zieht sich ein Spiel über mehr Runden hin, als in der Partie-Konfiguration über einen Höchstwert fest,  ohne dass ein Sieger ermittelt werden kann, so wird das Verhalten des Goldenen Schnatz angepasst. Die Wahrscheinlichkeit, dass ein Sucher den Goldenen Schnatz findet wird auf 100\% gesetzt. Falls dann nach drei Runden das Spiel immer noch läuft bewegt sich der Goldenen Schnatz ohne Suchern auszuweichen in die Mitte des Spielfelds und verharrt dort. Wird der dort nach weiteren drei Runden immer noch nicht gewunden, so fliegt er in der nächsten Rundenphase dem nächsten Sucher ins Gesicht.}
			{Dadurch wird sichergestellt das ein Spiel spannend bleibt und die Spieler nicht die Lust verlieren, wenn eine Partie zu zäh läuft.}
			{Spielende, Spiellogik, Runde, Goldener Schnatz, Sucher}
			{-+}
			{Spiel, Spieler}
	
	\fanf	{Zufallsgenerator}
			{Einheit die per Zufall entscheidet, ob bestimmt Ereignisse eintreten oder nicht.}
			{An mehreren Stellen in der Spiellogik ist es notwendig, dass via Zufall Entschieden wird ob ein Ereignis eintritt oder nicht. Dies ist z.B. der Fall wen entschieden werden muss ob der Schiedsrichter ein Foul ahndet oder wenn entschieden werden muss ob ein geworfener Ball geblockt wird.}
			{Spiellogik}
			{-+}
			{Server, Schiedsrichter}
			
	
	\subsection{Client spezifische Funktionale Anforderungen}
	
	\fanf	{Hauptmenü [Ansicht]}
			{Erste grafische Oberfläche die dem Nutzer angezeigt wird, wenn die Anwendung gestartet wurde.}
			{Das Hauptmenü soll den Zentralen Punkt darstellen von dem aus alle Funktionen der Software zu erreichen. Es soll also unter anderem ein Spiel gestartet werden können, die Hilfe aufgerufen werden können, die Einstellungen der Anwendung angepasst werden können und eventuell vorhandene Statistiken aufgerufen werden können.}
			{<Abhängigkeiten>}
			{+}
			{Nutzer}
	
	\fanf	{Spiel beitreten [Ansicht]}
			{Grafische Oberfläche um sich mit einem Server auf dem ein Spiel bereit gestellt wird zu verbinden. Dabei soll man außerdem die Möglichkeit haben seine Team-Konfiguration an zu geben, die man für das neue Spiel verwenden möchte.}
			{Der Nutzer muss die Möglichkeit haben sich komfortabel mit einem Server verbinden zu können.}
			{Abb.}
			{+}
			{Spieler, Gast}
	
	\fanf	{Spiel Ende [Ansicht]}
			{Grafische Oberfläche die, die Spieler sehen nachdem eine Partie zu Ende ist. Der Nutzer sollte hier auch die Möglichkeit haben die Anwendung zu verlassen oder wieder ins Hauptmenü zurück kehren. Optional ist hier auch Platz für etwaige Statistiken über den Spielverlauf.}
			{Nach dem Ende einer Partie muss dem Nutzer mitgeteilt werden ob er gewonnen hat oder nicht und wie es von da an weiter geht. }
			{<Abhängigkeiten>}
			{-+}
			{Spieler}
			
	\fanf	{Team-Konfiguration importieren [Ansicht]}
			{Grafische Oberfläche zum importieren bzw. öffnen einer Team-Konfiguration für ein Spiel.}
			{Es muss für den Benutzer eine einfachen Weg geben eine Team Konfiguration im Dateisystem zu suchen und an die Anwendung zu übergeben.}
			{<Abhängigkeiten>}
			{-+}
			{Spieler}
			
	\fanf	{Spiel [Ansicht]}
			{Grafische Oberfläche die der Spieler sieht.}
			{Es handelt sich um eine Anwendung mit grafischer Benutzeroberfläche. Es ist also zwingend von Nöten, dass such das aktuelle Spielgeschehen angezeigt werden kann.}
			{<Abhängigkeiten>}
			{++}
			{Spieler}	
			
	\fanf	{Hilfe [Ansicht]}
			{Grafische Oberfläche, in der zum einen das Spielprinzip erklärt wird und zum anderen gezeigt wird wie genau man die Client-Software bedient wird.}
			{Um unerfahren Benutzer die Bedienung der Software zu erleichtern.}
			{<Abhängigkeiten>}
			{-+}
			{Nutzer}
			
	\fanf	{Beobachter [Ansicht]}
			{Grafische Oberfläche, die ein Gast sieht.}
			{Wenn ein Nutzer einem Spiel nur als Gast zuschaut muss ihm das Spiel trotzdem in eine grafische Oberfläche aufbereitet werden.}
			{<Abhängigkeiten>}
			{+}
			{Gast}
	
	\fanf	{Spiel Rendering Engine}
			{Die Spiel Rendering Engine bereitet die Ansicht des Spielfelds grafisch auf.}
			{Die Benutzeroberfläche muss während des Spiels mit Inhalt gefüllt werden. Dieser Inhalt muss je nach Spielgeschehen automatisch generiert werden.}
			{<Abhängigkeiten>}
			{++}
			{Client, Spieler}
	
	\fanf	{Eingabenverarbeitung}
			{Diese Einheit ist für die Verarbeitung von Benutzereingaben verantwortlich.}
			{Jede Benutzereingabe muss ausgewertet werden. Nach der Validierung muss dann eine Entscheidung getroffen werden, was als Reaktion auf diese Eingaben passieren muss.}
			{Spiellogik}
			{++}
			{Spieler, KI}
			
	\fanf	{Eingaben Validierung}
			{Einheit die Benutzereingaben auf Korrektheit prüft.}
			{Um etwaige falsche Benutzereingaben zu erkennen und den Nutzer darauf hin weisen zu können ist es von Nöten, dass alle Benutzereingaben geprüft werden.}
			{Spiellogik}
			{<Prio>}
			{Spieler, KI}
	
	\fanf	{Hotkey}
			{Oft benötigte Funktionen auf bestimmte (besondere) Testen (-Kombinationen) abzubilden.}
			{Hotkeys sind optionale Features, die im Lastenheft aufgeführt sind und zu einer einfacheren Spielsteuerung und höherem Spielkomfort betragen können.}
			{<Abhängigkeiten>}
			{--}
			{Spieler}
			
	\fanf	{Pausieren}
			{Das aktuelle Spiel pausieren.}
			{Pausieren ist ein optionales Feature, das im Lastenheft aufgeführt ist und einem menschliche Spieler im Client zur Verfügung stehen sollte um den Spielkomfort zu erhöhen.}
			{<Abhängigkeiten>}
			{--}
			{Spieler}
			
	
	\subsection{Quidditchteam-Editor spezifische funktionale Anforderungen}
	
	\fanf	{Team Konfiguration bearbeiten}
			{Grafische Oberfläche in der der Nutzer sein Team nach seinen Wünschen entsprechend anpassen kann.}
			{Für das Bearbeiten des Teams soll dem Nutzer eine grafische Oberfläche bereit gestellt werden.}
			{Quidditchteam-Konfiguration}
			{-}
			{Nutzer}
			
	\fanf	{Team Konfiguration öffnen}
			{'Datei Öffnen' Dialog um die im \textit{JSON} Format gespeicherte Team-Konfiguration von einem beliebigen Ort im Dateisystem zu öffnen.}
			{Um eine hohe Benutzerfeindlichkeit zu garantieren muss es den Nutzer möglich sein einfach eine bereits erstellt Konfiguration für ein Team einzulesen und die zu bearbeiten.}
			{Team Konfiguration bearbeiten, Quidditchteam-Konfiguration}
			{-}
			{Nutzer}
	
	\fanf	{Team Konfiguration speichern}
			{'Datei Speichern' Dialog um die Team-Konfiguration an einem beliebigen Ort im Dateisystem im \textit{JSON} Format abzulegen.}
			{Ohne die Möglichkeit die Team-Konfiguration lokal permanent zu speichern wäre das Benutzererlebnis und die Bedienbarkeit der Software massiv beeinträchtigt.}
			{Team Konfiguration bearbeiten, Quidditchteam-Konfiguration}
			{-}
			{Nutzer}
			
	
	\subsection{Nicht funktionale Anforderungen}
	
	\qanf 	{Plattformunabhängigkeit}
			{Der Client und der Team-Konfigurator soll auf mindestens einer gängigen Computerbetriebssystem-Plattform (z.B. Linux, Windows) uneingeschränkt benutzbar sein. Des weiteren soll die Serveranwendung und der KI-Client auf mindestens zwei gängigen Computerbetriebssystem-Plattformen (z.B. Linux, Windows) uneingeschränkt benutzbar sein.}
			{Die Plattformunabhängigkeit ist von großer Bedeutung, da die Anwendungen auf möglichst vielen Zielsystemen funktionieren sollen um die Menge an Endnutzer so wenig wie möglich einzuschränken.}
			{Programmiersprache}
			{++}
			{Nutzer, Entwickler}
	
	\qanf 	{Version-Controlling}
			{Beim Verwalten des Quellcodes soll ein Git basiertes Version-Controlling Werkzeug (\textit{GitHub / GitLab}) verwendet werden.}
			{Durch das Verwenden eines Versionierungswerkzeuges wird das zusammenarbeiten unterschiedlicher Entwickler erleichtert, da das zusammenführen des Codes größtenteils automatisiert abläuft.}
			{-}
			{++}
			{Entwickler}
	
	\qanf 	{Continuous Integration}
			{In die Version-Controlling Lösung mit Hilfe einer CI automatisch jeder gepushte Commit Unit-Tests und der Statischen Codeanalyse unterzogen werden. Zudem soll eine automatisierte Code Dokumentation angestoßen werden. Bei erfolgreichem Abschließen alle Test soll zum Schluss der aktuelle Stand deployed werden.}
			{Die CI nimmt den Entwicklern Arbeit ab und kann dazu beitragen, dass Fehler frühzeitig erkannt und behoben werden können.}
			{-}
			{-+}
			{Entwickler}
	
	\qanf 	{Statische Codeanalyse}
			{Mit Hilfe des Tools 'SonarQube' bzw. 'SonarCloud' soll der gesamt Quellcode einer statischen Analyse unterzogen werden. Dabei darf die technische Codequalität von diesen Tool nicht schlechter als 'B' bewertet werden.}
			{Quellcode mit einer hohen Codequalität ist weniger anfällig für Fehler und Probleme.}
			{-}
			{+}
			{Entwickler}
	
	\qanf 	{Automatisierte Unit-Tests}
			{Alle definierten Unit-Tests müssen fehlerfrei bestanden werden.}
			{Da alle Komponenten möglichst fehlerfrei funktionieren müssen ist es unerlässlich die einzelnen Teil der Software ständig auf ihre Funktionalität zu prüfen, die ist nur effizient möglich wenn automatisiert Test durchgeführt werden, damit Fehler frühzeitig erkannt werden.}
			{-}
			{-+}
			{Entwickler}
	
	\qanf 	{Docker Container}
			{Um die Plattformunabhängigkeit zu gewährleisten soll sowohl die Server Komponente, als auch die KI-Komponenten mit Hilfe eines Docker Container veröffentlicht werden.}
			{Docker Container bieten den Vorteil, dass die Software nicht auf jedem Zielsystem neu compiliert werden muss sondern, sobald sie auf einem System in einem Docker-Container lauffähig gemacht wurde lässt sich dieser Container in der Regel auf diversen anderen Zielsystemen ausführen.}
			{Plattformunabhängigkeit}
			{+}
			{Entwickler}
	
	\qanf 	{Dokumentation}
			{Alle Klassen und Methoden der Software müssen dokumentiert werden. Dabei sollen mindestens alle Übergabeparameter und Rückgabewerte genau spezifiziert werden. Zudem ist sind komplexe Algorithmen detailliert zu dokumentieren. Die gesamte Dokumente ist dabei mit dem Tool Doxygen zu erstellen.}
			{Gut dokumentierte Software vereinfacht die Fehlersuche, die Wartung und das hinzufügen von neuen Features.}
			{-}
			{+}
			{<Akteure>}
	
	\qanf 	{Benutzerhandbuch}
			{Zu jeder Komponente des Projektes muss eine Benutzerhandbuch existieren, in welchem alle Features unmissverständlich erklärt sind, sodass ein neuer Benutzer auf Basis des Benutzerhandbuches die Software bedienen kann.}
			{Das Benutzerhandbuch wird im Lastenheft gefordert.}
			{Dokumentation}
			{-+}
			{Nutzer}
	
	\qanf 	{Anwendungssprache}
			{Das User-Interface der Anwendungen soll in deutscher Sprache gestaltet werden.}
			{Die Anwendungssprache ist im Lastenheft vorgegeben.}
			{-}
			{-+}
			{Nutzer}
	
	\qanf 	{Implementierungssprache}
			{Die Implementierung der Anwendungen soll in englischer Sprache gehalten sein.}
			{Die Implementierungssprache ist im Lastenheft vorgegeben.}
			{-}
			{-+}
			{Entwickler}
	
	\qanf 	{Dokumentationssprache}
			{Die Dokumentation der Software kann in englischer oder deutscher Sprache gestaltet sein.}
			{Die Dokumentationssprache ist im Lastenheft vorgegeben.}
			{-}
			{-+}
			{Entwickler}
	
	\qanf 	{Programmiersprache}
			{Die Software soll in einer der folgenden Programmiersprachen geschrieben sein: Java, C++, C\# Die endgültig verwendete Sprache kann jedoch von Komponente zu Komponente variieren, muss aber mit dem Kunden abgesprochen werden.}
			{Es soll eine Programmiersprache verwendet werden, welche von allen Teammitgliedern beherrscht wird.}
			{-}
			{++}
			{Entwickler}	
	
	\qanf 	{Format für Konfigurationsdateien}
			{Alle Konfigurationsdateien müssen dem \textit{JSON} Standard genügen. Des Weiteren sind alle vom Komitee festgelegten weiteren Standards einzuhalten.}
			{Durch Einheitliche Formate der Konfigurationsdateien lässt sich sicherstellen, das einzelne Komponenten zwischen den Entwicklungsteams ausgetauscht werden können und diese miteinander kompatibel sind. }
			{-}
			{+}
			{Entwickler, Nutzer}
	
	\qanf 	{Netzwerkkommunikation}
			{Die Netzwerkkommunikation zwischen Client und Server soll über sogenannte \textit{Web-Socket-Sessions} realisiert werden, sodass Client und Server ortsunabhängig von einander betrieben werden können.}
			{Die Netzwerkkommunikation muss gewissen Standards genügen, damit Client- und Serveranwendungen von unterschiedlichen Entwicklerteams mit einander kompatibel sind und Client und Server ortsunabhängig von einander betrieben werden können.}
			{-}
			{++}
			{Spiel}
	
	\qanf 	{Log-Dateien}
			{Log-Dateien anlegen um unter anderem den Spielverlauf zu Speichern und eventuelle Fehlfunktionen der Software fest zu halten.}
			{Log-Dateien können unter anderen die Wartung der Software erleichtern und für zusätzliche Features, wie eine Statistik über den Spielverlauf verwendet werden.}
			{-}
			{-}
			{Spiel}
	
	\qanf 	{Funktionalität}
			{Die Anwendungen müssen alle im Lastenheft als Minimalanforderungen aufgeführten Anforderungen erfüllen.}
			{Um die Abnahmen zu bestehen müssen die Minimalanforderungen erfüllt werden.}
			{-}
			{++}
			{Kunde, Nutzer, Entwickler}
	
	\qanf 	{Zuverlässigkeit}
			{Die Anwendungen dürfen niemals komplett abstürzen.}
			{Durch zu häufiges Abstürzen der Software ist das Benutzererlebnis massiv beeinträchtigt.}
			{Robustheit}
			{+}
			{Nutzer}
	
	\qanf 	{Robustheit}
			{Die Anwendungen dürfen nicht aufgrund einer Falschen Benutzereingabe abstürzen, sondern müssen den Benutzer auf seinen Fehler hinweisen.}
			{Um das Benutzererlebnis nicht zu beeinträchtigen und keine Sicherheitslücken zu verursachen ist es notwendig, dass die Funktion der Software nicht durch fehlerhafte Benutzereingaben beeinträchtigt wird.}
			{-}
			{++}
			{Nutzer}
	
	\qanf 	{Benutzbarkeit}
			{Dem Endnutzer muss es möglich sein alle Komponenten des Projektes nur auf Basis des Mitgelieferten Benutzerhandbuches und den Hilfeseiten die Software ohne Einschränkungen bedienen zu können.}
			{Wenn es für die Endnutzer der Software zu kompliziert ist die Software zu Benutzen, dann ist das Benutzererlebnis erheblich gestört und die Software wird nicht Benutzt werden, da die Endbenutzer unzufrieden sind.}
			{-}
			{+}
			{Nutzer}
			
	\qanf 	{Wartbarkeit}
			{Die Software muss so aufgebaut sein, dass einzelne Teilstücke bei Bedarf ohne Umbauten der übrigen Software ersetzbar sind.}
			{Im Falle einer Fehlfunktion in einem Teilstück der Software muss diese einfach austauschbar sein um den Fehler schnellst möglich beheben zu können. Zudem sollte das Hinzufügen weiterer Features möglich sein um das Produkt stetig weiter entwickeln zu können.}
			{-}
			{-+}
			{Entwickler}
	
	\qanf 	{Effizienz}
			{Die Software sollte Ressourcen schonend arbeiten. Keine Komponente darf mehr als ein Gigabyte Arbeitsspeicher benötigen und Keine Komponente darf mehr als 50\% der auf dem System zur Verfügung stehenden Prozessorleistung benötigen. Zudem darf im Durchschnitt während einer Partie nicht mehr als 1MBit/s an Netzwerkbandbreite benötigt werden um das Spiel ohne Einschränkungen nutzen zu können.}
			{Eine ressourcenschonende Anwendung ist auch auf älteren Zielsystemen problemlos nutzbar.}
			{-}
			{-}
			{Nutzer, Entwickler}
	
	\qanf 	{Kurze Ladezeiten}
			{Systembedingte Ladezeiten der Software dürfen auf einem aktuellen Computer zwei Sekunden pro geladenem Teil nicht überschreiten.}
			{Bei längeren Ladezeiten ist das Benutzererlebnis massiv beeinträchtigt.}
			{-}
			{-+}
			{Nutzer, Entwickler}
    
\end{document}
